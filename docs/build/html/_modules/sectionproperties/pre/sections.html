

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>sectionproperties.pre.sections &mdash; sectionproperties 1.0.6 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home"> sectionproperties
          

          
          </a>

          
            
            
              <div class="version">
                1.0.6
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/structure.html">Structure of an Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/geom_mesh.html">Creating a Geometry, Mesh and Material Properties</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/analysis.html">Running an Analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/post.html">Viewing the Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/api.html">Python API Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rst/theory.html">Theoretical Background</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sectionproperties</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
      <li>sectionproperties.pre.sections</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for sectionproperties.pre.sections</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">sectionproperties.pre.pre</span> <span class="k">as</span> <span class="nn">pre</span>
<span class="kn">import</span> <span class="nn">sectionproperties.post.post</span> <span class="k">as</span> <span class="nn">post</span>


<div class="viewcode-block" id="Geometry"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Geometry">[docs]</a><span class="k">class</span> <span class="nc">Geometry</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Parent class for a cross-section geometry input.</span>

<span class="sd">    Provides an interface for the user to specify the geometry defining a cross-section. A method</span>
<span class="sd">    is provided for generating a triangular mesh, for translating the cross-section by *(x, y)* and</span>
<span class="sd">    for plotting the geometry.</span>

<span class="sd">    :cvar points: List of points *(x, y)* defining the vertices of the cross-section</span>
<span class="sd">    :vartype points: list[list[float, float]]</span>
<span class="sd">    :cvar facets: List of point index pairs *(p1, p2)* defining the edges of the cross-section</span>
<span class="sd">    :vartype facets: list[list[int, int]]</span>
<span class="sd">    :cvar holes: List of points *(x, y)* defining the locations of holes within the cross-section.</span>
<span class="sd">        If there are no holes, provide an empty list [].</span>
<span class="sd">    :vartype holes: list[list[float, float]]</span>
<span class="sd">    :cvar control_points: A list of points *(x, y)* that define different regions of the</span>
<span class="sd">        cross-section. A control point is an arbitrary point within a region enclosed by facets.</span>
<span class="sd">    :vartype control_points: list[list[float, float]]</span>
<span class="sd">    :cvar shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :vartype shift: list[float, float]</span>
<span class="sd">    :cvar perimeter: List of facet indices defining the perimeter of the cross-section</span>
<span class="sd">    :vartype perimeter: list[int]</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the Geometry class.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span> <span class="o">=</span> <span class="n">control_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift</span> <span class="o">=</span> <span class="n">shift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="p">[]</span>

<div class="viewcode-block" id="Geometry.create_mesh"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Geometry.create_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">create_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mesh_sizes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a quadratic triangular mesh from the Geometry object.</span>

<span class="sd">        :param mesh_sizes: A list of maximum element areas corresponding to each region within the</span>
<span class="sd">            cross-section geometry.</span>
<span class="sd">        :type mesh_size: list[float]</span>

<span class="sd">        :return: Object containing generated mesh data</span>
<span class="sd">        :rtype: :class:`meshpy.triangle.MeshInfo`</span>

<span class="sd">        :raises AssertionError: If the number of mesh sizes does not match the number of regions</span>

<span class="sd">        The following example creates a circular cross-section with a diameter of 50 with 64</span>
<span class="sd">        points, and generates a mesh with a maximum triangular area of 2.5::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>

<span class="sd">            geometry = sections.CircularSection(d=50, n=64)</span>
<span class="sd">            mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>

<span class="sd">        ..  figure:: ../images/sections/circle_mesh.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Mesh generated from the above geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Number of mesh_sizes (</span><span class="si">{0}</span><span class="s2">), should match the number of regions (</span><span class="si">{1}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">mesh_sizes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh_sizes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">)),</span> <span class="nb">str</span>

        <span class="k">return</span> <span class="n">pre</span><span class="o">.</span><span class="n">create_mesh</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">,</span> <span class="n">mesh_sizes</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.shift_section"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.shift_section">[docs]</a>    <span class="k">def</span> <span class="nf">shift_section</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shifts the cross-section parameters by the class variable vector *shift*.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
            <span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.rotate_section"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.rotate_section">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">rot_point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Rotates the geometry and specified angle about a point. If the rotation point is not</span>
<span class="sd">        provided, rotates the section about the first control point in the list of control points</span>
<span class="sd">        of the :class:`~sectionproperties.pre.sections.Geometry` object.</span>

<span class="sd">        :param float angle: Angle (degrees) by which to rotate the section. A positive angle leads</span>
<span class="sd">            to a counter-clockwise rotation.</span>
<span class="sd">        :param rot_point: Point *(x, y)* about which to rotate the section</span>
<span class="sd">        :type rot_point: list[float, float]</span>

<span class="sd">        The following example rotates a 200UB25 section clockwise by 30 degrees::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>

<span class="sd">            geometry = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=8)</span>
<span class="sd">            geometry.rotate_section(angle=-30)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># convert angle to radians</span>
        <span class="n">rot_phi</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="k">def</span> <span class="nf">get_r</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns the distance between two points.&quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="p">((</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="k">def</span> <span class="nf">get_phi</span><span class="p">(</span><span class="n">pt1</span><span class="p">,</span> <span class="n">pt2</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns the angle between two points.&quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">rotate_point</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">,</span> <span class="n">rot_phi</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Rotates a point given a rotation point and rotation angle.&quot;&quot;&quot;</span>

            <span class="n">r</span> <span class="o">=</span> <span class="n">get_r</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">)</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">get_phi</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">)</span>

            <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">rot_phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">rot_point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span> <span class="o">+</span> <span class="n">rot_phi</span><span class="p">)</span> <span class="o">+</span> <span class="n">rot_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># use the first control point if no rotation point is specified</span>
        <span class="k">if</span> <span class="n">rot_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rot_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># rotate all the points</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">rotate_point</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">,</span> <span class="n">rot_phi</span><span class="p">)</span>

        <span class="c1"># rotate all the holes</span>
        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="n">rotate_point</span><span class="p">(</span><span class="n">hole</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">,</span> <span class="n">rot_phi</span><span class="p">)</span>

        <span class="c1"># rotate all the control points</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
            <span class="n">rotate_point</span><span class="p">(</span><span class="n">cp</span><span class="p">,</span> <span class="n">rot_point</span><span class="p">,</span> <span class="n">rot_phi</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.mirror_section"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.mirror_section">[docs]</a>    <span class="k">def</span> <span class="nf">mirror_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">mirror_point</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Mirrors the geometry about a point on either the x or y-axis. If no point is provided,</span>
<span class="sd">        mirrors the geometry about the first control point in the list of control points of the</span>
<span class="sd">        :class:`~sectionproperties.pre.sections.Geometry` object.</span>

<span class="sd">        :param string axis: Axis about which to mirror the geometry, *&#39;x&#39;* or *&#39;y&#39;*</span>
<span class="sd">        :param mirror_point: Point about which to mirror the geometry *(x, y)*</span>
<span class="sd">        :type mirror_point: list[float, float]</span>

<span class="sd">        The following example mirrors a 200PFC section about the y-axis and the point (0, 0)::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>

<span class="sd">            geometry = sections.PfcSection(d=200, b=75, t_f=12, t_w=6, r=12, n_r=8)</span>
<span class="sd">            geometry.mirror_section(axis=&#39;y&#39;, mirror_point=[0, 0])</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># use the first control point if no mirror point is specified</span>
        <span class="k">if</span> <span class="n">mirror_point</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mirror_point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># select the axis to mirror</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Enter a valid axis: &#39;x&#39; or &#39;y&#39;&quot;</span><span class="p">)</span>

        <span class="c1"># mirror all points</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mirror_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># mirror all holes</span>
        <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
            <span class="n">hole</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mirror_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">hole</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># mirror all control points</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
            <span class="n">cp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">mirror_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.add_point"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.add_point">[docs]</a>    <span class="k">def</span> <span class="nf">add_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a point to the geometry and returns the added point id.</span>

<span class="sd">        :param point: Location of the point</span>
<span class="sd">        :type point: list[float, float]</span>
<span class="sd">        :return: Point id</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Geometry.add_facet"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.add_facet">[docs]</a>    <span class="k">def</span> <span class="nf">add_facet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a facet to the geometry and returns the added facet id.</span>

<span class="sd">        :param facet: Point indices of the facet</span>
<span class="sd">        :type facet: list[float, float]</span>
<span class="sd">        :return: Facet id</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">facet</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Geometry.add_hole"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.add_hole">[docs]</a>    <span class="k">def</span> <span class="nf">add_hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hole</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a hole location to the geometry and returns the added hole id.</span>

<span class="sd">        :param hole: Location of the hole</span>
<span class="sd">        :type hole: list[float, float]</span>
<span class="sd">        :return: Hole id</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hole</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Geometry.add_control_point"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.add_control_point">[docs]</a>    <span class="k">def</span> <span class="nf">add_control_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">control_point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a control point to the geometry and returns the added control</span>
<span class="sd">        point id.</span>

<span class="sd">        :param hole: Location of the control point</span>
<span class="sd">        :type hole: list[float, float]</span>
<span class="sd">        :return: Control point id</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">control_point</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="Geometry.clean_geometry"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Geometry.clean_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">clean_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Peforms a full clean on the geometry.</span>

<span class="sd">        :param bool verbose: If set to true, information related to the geometry cleaning process</span>
<span class="sd">            is printed to the terminal.</span>

<span class="sd">        ..  note:: Cleaning the geometry is always recommended when creating a merged section,</span>
<span class="sd">          which may result in overlapping or intersecting facets, or duplicate nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span> <span class="o">=</span> <span class="n">pre</span><span class="o">.</span><span class="n">GeometryCleaner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span><span class="o">.</span><span class="n">clean_geometry</span><span class="p">()</span></div>

<div class="viewcode-block" id="Geometry.plot_geometry"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Geometry.plot_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">plot_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pause</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">perimeter</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the geometry defined by the input section. If no axes object is supplied a new</span>
<span class="sd">        figure and axis is created.</span>

<span class="sd">        :param ax: Axes object on which the mesh is plotted</span>
<span class="sd">        :type ax: :class:`matplotlib.axes.Axes`</span>
<span class="sd">        :param bool pause: If set to true, the figure pauses the script until the window is closed.</span>
<span class="sd">            If set to false, the script continues immediately after the window is rendered.</span>
<span class="sd">        :param bool labels: If set to true, node and facet labels are displayed</span>
<span class="sd">        :param bool perimeter: If set to true, boldens the perimeter of the cross-section</span>

<span class="sd">        The following example creates a CHS discretised with 64 points, with a diameter of 48 and</span>
<span class="sd">        thickness of 3.2, and plots the geometry::</span>

<span class="sd">            import sectionproperties.pre.sections as sections</span>

<span class="sd">            geometry = sections.Chs(d=48, t=3.2, n=64)</span>
<span class="sd">            geometry.plot_geometry()</span>

<span class="sd">        ..  figure:: ../images/sections/chs_geometry.png</span>
<span class="sd">            :align: center</span>
<span class="sd">            :scale: 75 %</span>

<span class="sd">            Geometry generated by the above example.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># if no axes object is supplied, create and setup the plot</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ax_supplied</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="p">(</span><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
            <span class="n">post</span><span class="o">.</span><span class="n">setup_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ax_supplied</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">perimeter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span><span class="p">:</span>
                    <span class="n">linewidth</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linewidth</span> <span class="o">=</span> <span class="mf">1.5</span>

            <span class="c1"># plot the points and facets</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Points &amp; Facets&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]],</span>
                        <span class="s1">&#39;ko-&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="p">):</span>
            <span class="c1"># plot the holes</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Holes&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">h</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;rx&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">cp</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="p">):</span>
            <span class="c1"># plot the control points</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                        <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Control Points&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">markerSize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

        <span class="c1"># display the legend</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;center left&#39;</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">))</span>

        <span class="c1"># display the labels</span>
        <span class="k">if</span> <span class="n">labels</span><span class="p">:</span>
            <span class="c1"># plot node labels</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="n">pt</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

            <span class="c1"># plot facet labels</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">fct</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">):</span>
                <span class="n">pt1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">fct</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">pt2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">fct</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="p">[(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span>

                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">xy</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

        <span class="c1"># if no axes object is supplied, finish the plot</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ax_supplied</span><span class="p">:</span>
            <span class="n">post</span><span class="o">.</span><span class="n">finish_plot</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">pause</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Cross-Section Geometry&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.calculate_extents"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.calculate_extents">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the minimum and maximum x and y-values amongst the list of points.</span>

<span class="sd">        :return: Minimum and maximum x and y-values *(x_min, x_max, y_min, y_max)*</span>
<span class="sd">        :rtype: tuple(float, float, float, float)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># loop through all points</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># initialise min, max variables</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x_min</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">x_max</span> <span class="o">=</span> <span class="n">x</span>
                <span class="n">y_min</span> <span class="o">=</span> <span class="n">y</span>
                <span class="n">y_max</span> <span class="o">=</span> <span class="n">y</span>

            <span class="c1"># update the mins and maxs where necessary</span>
            <span class="n">x_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">x_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x_max</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">y_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y_min</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">y_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y_max</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">,</span> <span class="n">y_min</span><span class="p">,</span> <span class="n">y_max</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.draw_radius"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.draw_radius">[docs]</a>    <span class="k">def</span> <span class="nf">draw_radius</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">anti</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds a quarter radius of points to the points list - centered at point *pt*, with radius</span>
<span class="sd">        *r*, starting at angle *theta*, with *n* points. If r = 0, adds pt only.</span>

<span class="sd">        :param pt: Centre of radius *(x,y)*</span>
<span class="sd">        :type pt: list[float, float]</span>
<span class="sd">        :param float r: Radius</span>
<span class="sd">        :param float theta: Initial angle</span>
<span class="sd">        :param int n: Number of points</span>
<span class="sd">        :param bool anti: Anticlockwise rotation?</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">anti</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mult</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># calculate radius of points</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine angle</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">theta</span> <span class="o">+</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span></div>

<div class="viewcode-block" id="Geometry.calculate_facet_length"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.calculate_facet_length">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_facet_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facet</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the length of the facet.</span>

<span class="sd">        :param facet: Point index pair *(p1, p2)* defining a facet</span>
<span class="sd">        :vartype facets: list[int, int]</span>

<span class="sd">        :return: Facet length</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># get facet points</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">facet</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">facet</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="c1"># calculate distance between two points</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.calculate_perimeter"><a class="viewcode-back" href="../../../rst/api.html#sectionproperties.pre.sections.Geometry.calculate_perimeter">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_perimeter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates the perimeter of the cross-section by summing the length of all facets in the</span>
<span class="sd">        ``perimeter`` class variable.</span>

<span class="sd">        :return: Cross-section perimeter, returns 0 if there is no perimeter defined</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># check to see if there are any facets in the perimeter variable</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="c1"># initialise perimeter variable</span>
        <span class="n">perimeter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># loop through all the facets along the perimeter</span>
        <span class="k">for</span> <span class="n">facet_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span><span class="p">:</span>
            <span class="n">perimeter</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_facet_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">[</span><span class="n">facet_idx</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">perimeter</span></div></div>


<div class="viewcode-block" id="CustomSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.CustomSection">[docs]</a><span class="k">class</span> <span class="nc">CustomSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a cross-section from a list of points, facets, holes and a user specified control</span>
<span class="sd">    point.</span>

<span class="sd">    :param points: List of points *(x, y)* defining the vertices of the cross-section</span>
<span class="sd">    :type points: list[list[float, float]]</span>
<span class="sd">    :param facets: List of point index pairs *(p1, p2)* defining the edges of the cross-section</span>
<span class="sd">    :type facets: list[list[int, int]]</span>
<span class="sd">    :param holes: List of points *(x, y)* defining the locations of holes within the cross-section.</span>
<span class="sd">        If there are no holes, provide an empty list [].</span>
<span class="sd">    :type holes: list[list[float, float]]</span>
<span class="sd">    :param control_points: A list of points *(x, y)* that define different regions of the</span>
<span class="sd">        cross-section. A control point is an arbitrary point within a region enclosed by facets.</span>
<span class="sd">    :type control_points: list[list[float, float]]</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>
<span class="sd">    :param perimeter: List of facet indices defining the perimeter of the cross-section</span>
<span class="sd">    :vartype perimeter: list[int]</span>

<span class="sd">    The following example creates a hollow trapezium with a base width of 100, top width of 50,</span>
<span class="sd">    height of 50 and a wall thickness of 10. A mesh is generated with a maximum triangular area of</span>
<span class="sd">    2.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        points = [[0, 0], [100, 0], [75, 50], [25, 50], [15, 10], [85, 10], [70, 40], [30, 40]]</span>
<span class="sd">        facets = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4]]</span>
<span class="sd">        holes = [[50, 25]]</span>
<span class="sd">        control_points = [[5, 5]]</span>
<span class="sd">        perimeter = [0, 1, 2, 3]</span>

<span class="sd">        geometry = sections.CustomSection(</span>
<span class="sd">            points, facets, holes, control_points, perimeter=perimeter</span>
<span class="sd">        )</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.0])</span>

<span class="sd">    ..  figure:: ../images/sections/custom_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Custom section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/custom_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">facets</span><span class="p">,</span> <span class="n">holes</span><span class="p">,</span> <span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">perimeter</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CustomSection class.&quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="n">facets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="n">holes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="n">perimeter</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="RectangularSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.RectangularSection">[docs]</a><span class="k">class</span> <span class="nc">RectangularSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a rectangular section with the bottom left corner at the origin *(0, 0)*, with</span>
<span class="sd">    depth *d* and width *b*.</span>

<span class="sd">    :param float d: Depth (y) of the rectangle</span>
<span class="sd">    :param float b: Width (x) of the rectangle</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a rectangular cross-section with a depth of 100 and width of 50,</span>
<span class="sd">    and generates a mesh with a maximum triangular area of 5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.RectangularSection(d=100, b=50)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5])</span>

<span class="sd">    ..  figure:: ../images/sections/rectangle_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Rectangular section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/rectangle_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the RectangularSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># construct the points and facets</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CircularSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.CircularSection">[docs]</a><span class="k">class</span> <span class="nc">CircularSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a solid circle centered at the origin *(0, 0)* with diameter *d* and using *n*</span>
<span class="sd">    points to construct the circle.</span>

<span class="sd">    :param float d: Diameter of the circle</span>
<span class="sd">    :param int n: Number of points discretising the circle</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a circular cross-section with a diameter of 50 with 64 points,</span>
<span class="sd">    and generates a mesh with a maximum triangular area of 2.5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CircularSection(d=50, n=64)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.5])</span>

<span class="sd">    ..  figure:: ../images/sections/circle_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Circular section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/circle_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CircularSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># loop through each point on the circle</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of the point</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current point to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the circle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="Chs"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Chs">[docs]</a><span class="k">class</span> <span class="nc">Chs</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a circular hollow section centered at the origin *(0, 0)*, with diameter *d* and</span>
<span class="sd">    thickness *t*, using *n* points to construct the inner and outer circles.</span>

<span class="sd">    :param float d: Outer diameter of the CHS</span>
<span class="sd">    :param float t: Thickness of the CHS</span>
<span class="sd">    :param int n: Number of points discretising the inner and outer circles</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a CHS discretised with 64 points, with a diameter of 48 and</span>
<span class="sd">    thickness of 3.2, and generates a mesh with a maximum triangular area of 1.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.Chs(d=48, t=3.2, n=64)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[1.0])</span>

<span class="sd">    ..  figure:: ../images/sections/chs_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        CHS geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/chs_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the Chs class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># specify a hole in the centre of the CHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># loop through each point of the CHS</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of outer and inner points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the circle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="EllipticalSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.EllipticalSection">[docs]</a><span class="k">class</span> <span class="nc">EllipticalSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a solid ellipse centered at the origin *(0, 0)* with vertical diameter *d_y* and</span>
<span class="sd">    horizontal diameter *d_x*, using *n* points to construct the ellipse.</span>

<span class="sd">    :param float d_y: Diameter of the ellipse in the y-dimension</span>
<span class="sd">    :param float d_x: Diameter of the ellipse in the x-dimension</span>
<span class="sd">    :param int n: Number of points discretising the ellipse</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an elliptical cross-section with a vertical diameter of 25 and</span>
<span class="sd">    horizontal diameter of 50, with 40 points, and generates a mesh with a maximum triangular area</span>
<span class="sd">    of 1.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.EllipticalSection(d_y=25, d_x=50, n=40)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[1.0])</span>

<span class="sd">    ..  figure:: ../images/sections/ellipse_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Elliptical section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/ellipse_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_x</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the EllipticalSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point centered at zero</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># loop through each point on the ellipse</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of the point</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current point to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the ellipse</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="Ehs"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Ehs">[docs]</a><span class="k">class</span> <span class="nc">Ehs</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs an elliptical hollow section centered at the origin *(0, 0)*, with outer vertical</span>
<span class="sd">    diameter *d_y*, outer horizontal diameter *d_x*, and thickness *t*, using *n* points to</span>
<span class="sd">    construct the inner and outer ellipses.</span>

<span class="sd">    :param float d_y: Diameter of the ellipse in the y-dimension</span>
<span class="sd">    :param float d_x: Diameter of the ellipse in the x-dimension</span>
<span class="sd">    :param float t: Thickness of the EHS</span>
<span class="sd">    :param int n: Number of points discretising the inner and outer ellipses</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a EHS discretised with 30 points, with a outer vertical diameter</span>
<span class="sd">    of 25, outer horizontal diameter of 50, and thickness of 2.0, and generates a mesh with a</span>
<span class="sd">    maximum triangular area of 0.5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.Ehs(d_y=25, d_x=50, t=2.0, n=64)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.5])</span>

<span class="sd">    ..  figure:: ../images/sections/ehs_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        EHS geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/ehs_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d_y</span><span class="p">,</span> <span class="n">d_x</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the Ehs class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[(</span><span class="n">d_x</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">),</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># specify a hole in the centre of the EHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># loop through each point of the EHS</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">n</span>

            <span class="c1"># calculate location of outer and inner points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_x</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_y</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_x</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="p">((</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">d_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current points to the points list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the circle</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="Rhs"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.Rhs">[docs]</a><span class="k">class</span> <span class="nc">Rhs</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a rectangular hollow section centered at *(b/2, d/2)*, with depth *d*, width *b*,</span>
<span class="sd">    thickness *t* and outer radius *r_out*, using *n_r* points to construct the inner and outer</span>
<span class="sd">    radii. If the outer radius is less than the thickness of the RHS, the inner radius is set to</span>
<span class="sd">    zero.</span>

<span class="sd">    :param float d: Depth of the RHS</span>
<span class="sd">    :param float b: Width of the RHS</span>
<span class="sd">    :param float t: Thickness of the RHS</span>
<span class="sd">    :param float r_out: Outer radius of the RHS</span>
<span class="sd">    :param int n_r: Number of points discretising the inner and outer radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an RHS with a depth of 100, a width of 50, a thickness of 6 and</span>
<span class="sd">    an outer radius of 9, using 8 points to discretise the inner and outer radii. A mesh is</span>
<span class="sd">    generated with a maximum triangular area of 2.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.Rhs(d=100, b=50, t=6, r_out=9, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.0])</span>

<span class="sd">    ..  figure:: ../images/sections/rhs_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        RHS geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/rhs_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the Rhs class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># specify a hole in the centre of the RHS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="c1"># calculate internal radius</span>
        <span class="n">r_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># construct the outer radius points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the outer radius facet list</span>
        <span class="n">n_outer</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_outer</span><span class="p">):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n_outer</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the inner radius points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the inner radius facet list</span>
        <span class="n">n_inner</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_outer</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_inner</span><span class="p">):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">n_inner</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_outer</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n_outer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_outer</span><span class="p">,</span> <span class="n">n_outer</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="ISection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.ISection">[docs]</a><span class="k">class</span> <span class="nc">ISection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs an I-section centered at *(b/2, d/2)*, with depth *d*, width *b*, flange</span>
<span class="sd">    thickness *t_f*, web thickness *t_w*, and root radius *r*, using *n_r* points to construct the</span>
<span class="sd">    root radius.</span>

<span class="sd">    :param float d: Depth of the I-section</span>
<span class="sd">    :param float b: Width of the I-section</span>
<span class="sd">    :param float t_f: Flange thickness of the I-section</span>
<span class="sd">    :param float t_w: Web thickness of the I-section</span>
<span class="sd">    :param float r: Root radius of the I-section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an I-section with a depth of 203, a width of 133, a flange</span>
<span class="sd">    thickness of 7.8, a web thickness of 5.8 and a root radius of 8.9, using 16 points to</span>
<span class="sd">    discretise the root radius. A mesh is generated with a maximum triangular area of 3.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[3.0])</span>

<span class="sd">    ..  figure:: ../images/sections/isection_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        I-section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/isection_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ISection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the top right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the next four points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the last point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="MonoISection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.MonoISection">[docs]</a><span class="k">class</span> <span class="nc">MonoISection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a monosymmetric I-section centered at *(max(b_t, b_b)/2, d/2)*, with depth *d*,</span>
<span class="sd">    top flange width *b_t*, bottom flange width *b_b*, top flange thickness *t_ft*, top flange</span>
<span class="sd">    thickness *t_fb*, web thickness *t_w*, and root radius *r*, using *n_r* points to construct the</span>
<span class="sd">    root radius.</span>

<span class="sd">    :param float d: Depth of the I-section</span>
<span class="sd">    :param float b_t: Top flange width</span>
<span class="sd">    :param float b_b: Bottom flange width</span>
<span class="sd">    :param float t_ft: Top flange thickness of the I-section</span>
<span class="sd">    :param float t_fb: Bottom flange thickness of the I-section</span>
<span class="sd">    :param float t_w: Web thickness of the I-section</span>
<span class="sd">    :param float r: Root radius of the I-section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a monosymmetric I-section with a depth of 200, a top flange width</span>
<span class="sd">    of 50, a top flange thickness of 12, a bottom flange width of 130, a bottom flange thickness of</span>
<span class="sd">    8, a web thickness of 6 and a root radius of 8, using 16 points to discretise the root radius.</span>
<span class="sd">    A mesh is generated with a maximum triangular area of 3.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.MonoISection(</span>
<span class="sd">            d=200, b_t=50, b_b=130, t_ft=12, t_fb=8, t_w=6, r=8, n_r=16</span>
<span class="sd">        )</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[3.0])</span>

<span class="sd">    ..  figure:: ../images/sections/monoisection_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        I-section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/monoisection_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">,</span> <span class="n">t_ft</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ISection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">max</span><span class="p">(</span><span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate central axis</span>
        <span class="n">x_central</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>

        <span class="c1"># add first three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">b_b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">b_b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">b_b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">t_fb</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the top right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the next four points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">b_t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">+</span> <span class="n">b_t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">b_t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">b_t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">t_fb</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the last point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_central</span> <span class="o">-</span> <span class="n">b_b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="TaperedFlangeISection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.TaperedFlangeISection">[docs]</a><span class="k">class</span> <span class="nc">TaperedFlangeISection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Tapered Flange I-section centered at *(b/2, d/2)*, with depth *d*, width *b*,</span>
<span class="sd">    mid-flange thickness *t_f*, web thickness *t_w*, root radius *r_r*, flange radius *r_f* and</span>
<span class="sd">    flange angle *alpha*, using *n_r* points to construct the radii.</span>

<span class="sd">    :param float d: Depth of the Tapered Flange I-section</span>
<span class="sd">    :param float b: Width of the Tapered Flange I-section</span>
<span class="sd">    :param float t_f: Mid-flange thickness of the Tapered Flange I-section (measured at the point</span>
<span class="sd">        equidistant from the face of the web to the edge of the flange)</span>
<span class="sd">    :param float t_w: Web thickness of the Tapered Flange I-section</span>
<span class="sd">    :param float r_r: Root radius of the Tapered Flange I-section</span>
<span class="sd">    :param float r_f: Flange radius of the Tapered Flange I-section</span>
<span class="sd">    :param float alpha: Flange angle of the Tapered Flange I-section (degrees)</span>
<span class="sd">    :param int n_r: Number of points discretising the radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Tapered Flange I-section with a depth of 588, a width of 191, a</span>
<span class="sd">    mid-flange thickness of 27.2, a web thickness of 15.2, a root radius of 17.8, a flange radius</span>
<span class="sd">    of 8.9 and a flange angle of 8, using 16 points to discretise the radii. A mesh is generated</span>
<span class="sd">    with a maximum triangular area of 20.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.TaperedFlangeISection(</span>
<span class="sd">            d=588, b=191, t_f=27.2, t_w=15.2, r_r=17.8, r_f=8.9, alpha=8, n_r=16</span>
<span class="sd">        )</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[20.0])</span>

<span class="sd">    ..  figure:: ../images/sections/taperedisection_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        I-section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/taperedisection_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r_r</span><span class="p">,</span> <span class="n">r_f</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ISection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate alpha in radians</span>
        <span class="n">alpha_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="c1"># calculate the height of the flange toe and dimensions of the straight</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.25</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>
        <span class="n">y_t</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the bottom right flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the bottom right root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># construct the top left flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">))</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top left root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the bottom left root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the bottom left flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="PfcSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.PfcSection">[docs]</a><span class="k">class</span> <span class="nc">PfcSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a PFC section with the bottom left corner at the origin *(0, 0)*, with depth *d*,</span>
<span class="sd">    width *b*, flange thickness *t_f*, web  thickness *t_w* and root radius *r*, using *n_r* points</span>
<span class="sd">    to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the PFC section</span>
<span class="sd">    :param float b: Width of the PFC section</span>
<span class="sd">    :param float t_f: Flange thickness of the PFC section</span>
<span class="sd">    :param float t_w: Web thickness of the PFC section</span>
<span class="sd">    :param float r: Root radius of the PFC section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a PFC section with a depth of 250, a width of 90, a flange</span>
<span class="sd">    thickness of 15, a web thickness of 8 and a root radius of 12, using 8 points to discretise the</span>
<span class="sd">    root radius. A mesh is generated with a maximum triangular area of 5.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.PfcSection(d=250, b=90, t_f=15, t_w=8, r=12, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0])</span>

<span class="sd">    ..  figure:: ../images/sections/pfc_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        PFC geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/pfc_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the PfcSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_w</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the top right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">t_w</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add last three points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="TaperedFlangeChannel"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.TaperedFlangeChannel">[docs]</a><span class="k">class</span> <span class="nc">TaperedFlangeChannel</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Tapered Flange Channel section with the bottom left corner at the origin</span>
<span class="sd">    *(0, 0)*, with depth *d*, width *b*, mid-flange thickness *t_f*, web thickness *t_w*, root</span>
<span class="sd">    radius *r_r*, flange radius *r_f* and flange angle *alpha*, using *n_r* points to construct the</span>
<span class="sd">    radii.</span>

<span class="sd">    :param float d: Depth of the Tapered Flange Channel section</span>
<span class="sd">    :param float b: Width of the Tapered Flange Channel section</span>
<span class="sd">    :param float t_f: Mid-flange thickness of the Tapered Flange Channel section (measured at the</span>
<span class="sd">        point equidistant from the face of the web to the edge of the flange)</span>
<span class="sd">    :param float t_w: Web thickness of the Tapered Flange Channel section</span>
<span class="sd">    :param float r_r: Root radius of the Tapered Flange Channel section</span>
<span class="sd">    :param float r_f: Flange radius of the Tapered Flange Channel section</span>
<span class="sd">    :param float alpha: Flange angle of the Tapered Flange Channel section (degrees)</span>
<span class="sd">    :param int n_r: Number of points discretising the radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Tapered Flange Channel section with a depth of 10, a width of</span>
<span class="sd">    3.5, a mid-flange thickness of 0.575, a web thickness of 0.475, a root radius of 0.575, a</span>
<span class="sd">    flange radius of 0.4 and a flange angle of 8, using 16 points to discretise the radii. A mesh</span>
<span class="sd">    is generated with a maximum triangular area of 0.02::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.TaperedFlangeChannel(</span>
<span class="sd">            d=10, b=3.5, t_f=0.575, t_w=0.475, r_r=0.575, r_f=0.4, alpha=8, n_r=16</span>
<span class="sd">        )</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.02])</span>

<span class="sd">    ..  figure:: ../images/sections/taperedchannel_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        I-section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/taperedchannel_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r_r</span><span class="p">,</span> <span class="n">r_f</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ISection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate alpha in radians</span>
        <span class="n">alpha_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">/</span> <span class="mi">180</span>

        <span class="c1"># calculate the height of the flange toe and dimensions of the straight</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">x2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>
        <span class="n">y_t</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the bottom right flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the bottom right root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t_w</span><span class="p">,</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">3.0</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">t_w</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">t_f</span> <span class="o">+</span> <span class="n">y2</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right root radius</span>
        <span class="k">if</span> <span class="n">r_r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t_w</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">t_w</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">y2</span> <span class="o">-</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="n">r_r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span>
                    <span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># construct the top right flange toe radius</span>
        <span class="k">if</span> <span class="n">r_f</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
                <span class="c1"># determine polar angle</span>
                <span class="n">theta</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="mf">3.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">alpha_rad</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">alpha_rad</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># calculate the locations of the radius points</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">b</span> <span class="o">-</span> <span class="n">r_f</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">d</span> <span class="o">-</span> <span class="n">y_t</span> <span class="o">+</span> <span class="n">r_f</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

                <span class="c1"># append the current points to the points list</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="c1"># add the final two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="TeeSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.TeeSection">[docs]</a><span class="k">class</span> <span class="nc">TeeSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Tee section with the top left corner at *(0, d)*, with depth *d*, width *b*,</span>
<span class="sd">    flange thickness *t_f*, web thickness *t_w* and root radius *r*, using *n_r* points to</span>
<span class="sd">    construct the root radius.</span>

<span class="sd">    :param float d: Depth of the Tee section</span>
<span class="sd">    :param float b: Width of the Tee section</span>
<span class="sd">    :param float t_f: Flange thickness of the Tee section</span>
<span class="sd">    :param float t_w: Web thickness of the Tee section</span>
<span class="sd">    :param float r: Root radius of the Tee section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Tee section with a depth of 200, a width of 100, a flange</span>
<span class="sd">    thickness of 12, a web thickness of 6 and a root radius of 8, using 8 points to discretise the</span>
<span class="sd">    root radius. A mesh is generated with a maximum triangular area of 3.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.TeeSection(d=200, b=100, t_f=12, t_w=6, r=8, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[3.0])</span>

<span class="sd">    ..  figure:: ../images/sections/tee_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Tee section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/tee_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t_f</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the TeeSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add next four points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">t_w</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_f</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="AngleSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.AngleSection">[docs]</a><span class="k">class</span> <span class="nc">AngleSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs an angle section with the bottom left corner at the origin *(0, 0)*, with depth</span>
<span class="sd">    *d*, width *b*, thickness *t*, root radius *r_r* and toe radius *r_t*, using *n_r* points to</span>
<span class="sd">    construct the radii.</span>

<span class="sd">    :param float d: Depth of the angle section</span>
<span class="sd">    :param float b: Width of the angle section</span>
<span class="sd">    :param float t: Thickness of the angle section</span>
<span class="sd">    :param float r_r: Root radius of the angle section</span>
<span class="sd">    :param float r_t: Toe radius of the angle section</span>
<span class="sd">    :param int n_r: Number of points discretising the radii</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates an angle section with a depth of 150, a width of 100, a thickness</span>
<span class="sd">    of 8, a root radius of 12 and a toe radius of 5, using 16 points to discretise the radii. A</span>
<span class="sd">    mesh is generated with a maximum triangular area of 2.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.AngleSection(d=150, b=100, t=8, r_r=12, r_t=5, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[2.0])</span>

<span class="sd">    ..  figure:: ../images/sections/angle_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Angle section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/angle_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_r</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the AngleSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># construct the bottom toe radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_t</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the root radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_r</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r_r</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the top toe radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="o">-</span> <span class="n">r_t</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_t</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r_t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># add the next point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CeeSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.CeeSection">[docs]</a><span class="k">class</span> <span class="nc">CeeSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Cee section with the bottom left corner at the origin *(0, 0)*, with depth *d*,</span>
<span class="sd">    width *b*, lip *l*, thickness *t* and outer radius *r_out*, using *n_r* points to construct the</span>
<span class="sd">    radius. If the outer radius is less than the thickness of the Cee Section, the inner radius is</span>
<span class="sd">    set to zero.</span>

<span class="sd">    :param float d: Depth of the Cee section</span>
<span class="sd">    :param float b: Width of the Cee section</span>
<span class="sd">    :param float l: Lip of the Cee section</span>
<span class="sd">    :param float t: Thickness of the Cee section</span>
<span class="sd">    :param float r_out: Outer radius of the Cee section</span>
<span class="sd">    :param int n_r: Number of points discretising the outer radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>
<span class="sd">    :raises Exception: Lip length must be greater than the outer radius</span>

<span class="sd">    The following example creates a Cee section with a depth of 125, a width of 50, a lip of 30, a</span>
<span class="sd">    thickness of 1.5 and an outer radius of 6, using 8 points to discretise the radius. A mesh is</span>
<span class="sd">    generated with a maximum triangular area of 0.25::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CeeSection(d=125, b=50, l=30, t=1.5, r_out=6, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.25])</span>

<span class="sd">    ..  figure:: ../images/sections/cee_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Cee section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/cee_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CeeSection class.&quot;&quot;&quot;</span>

        <span class="c1"># ensure the lip length is greater than the outer radius</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r_out</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Lip length must be greater than the outer radius&#39;</span><span class="p">)</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate internal radius</span>
        <span class="n">r_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># construct the outer bottom left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the outer bottom right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r_out</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="c1"># add next two points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the inner bottom left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the inner top left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the inner top right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span>
            <span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r_out</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="c1"># add next two points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the outer top right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the outer top left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="ZedSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.ZedSection">[docs]</a><span class="k">class</span> <span class="nc">ZedSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Zed section with the bottom left corner at the origin *(0, 0)*, with depth *d*,</span>
<span class="sd">    left flange width *b_l*, right flange width *b_r*, lip *l*, thickness *t* and outer radius</span>
<span class="sd">    *r_out*, using *n_r* points to construct the radius. If the outer radius is less than the</span>
<span class="sd">    thickness of the Zed Section, the inner radius is set to zero.</span>

<span class="sd">    :param float d: Depth of the Zed section</span>
<span class="sd">    :param float b_l: Left flange width of the Zed section</span>
<span class="sd">    :param float b_r: Right flange width of the Zed section</span>
<span class="sd">    :param float l: Lip of the Zed section</span>
<span class="sd">    :param float t: Thickness of the Zed section</span>
<span class="sd">    :param float r_out: Outer radius of the Zed section</span>
<span class="sd">    :param int n_r: Number of points discretising the outer radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>
<span class="sd">    :raises Exception: Lip length must be greater than the outer radius</span>

<span class="sd">    The following example creates a Zed section with a depth of 100, a left flange width of 40, a</span>
<span class="sd">    right flange width of 50, a lip of 20, a thickness of 1.2 and an outer radius of 5, using 8</span>
<span class="sd">    points to discretise the radius. A mesh is generated with a maximum triangular area of 0.15::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.ZedSection(d=100, b_l=40, b_r=50, l=20, t=1.2, r_out=5, n_r=8)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[0.15])</span>

<span class="sd">    ..  figure:: ../images/sections/zed_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Zed section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/zed_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the ZedSection class.&quot;&quot;&quot;</span>

        <span class="c1"># ensure the lip length is greater than the outer radius</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">r_out</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Lip length must be greater than the outer radius&#39;</span><span class="p">)</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate internal radius</span>
        <span class="n">r_in</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">r_out</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># construct the outer bottom left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the outer bottom right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b_r</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r_out</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="c1"># add next two points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b_r</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">b_r</span> <span class="o">-</span> <span class="n">t</span><span class="p">,</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner bottom right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">b_r</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the inner bottom left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the outer top right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="c1"># construct the outer top left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">r_out</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">r_out</span><span class="p">],</span> <span class="n">r_out</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">r_out</span> <span class="o">!=</span> <span class="n">l</span><span class="p">:</span>
            <span class="c1"># add the next two points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">l</span><span class="p">])</span>

        <span class="c1"># construct the inner top left radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="mi">2</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">+</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># construct the inner top right radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">([</span><span class="o">-</span><span class="n">r_in</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r_in</span><span class="p">],</span> <span class="n">r_in</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="CruciformSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.CruciformSection">[docs]</a><span class="k">class</span> <span class="nc">CruciformSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a cruciform section centered at the origin *(0, 0)*, with depth *d*, width *b*,</span>
<span class="sd">    thickness *t* and root radius *r*, using *n_r* points to construct the root radius.</span>

<span class="sd">    :param float d: Depth of the cruciform section</span>
<span class="sd">    :param float b: Width of the cruciform section</span>
<span class="sd">    :param float t: Thickness of the cruciform section</span>
<span class="sd">    :param float r: Root radius of the cruciform section</span>
<span class="sd">    :param int n_r: Number of points discretising the root radius</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a cruciform section with a depth of 250, a width of 175, a</span>
<span class="sd">    thickness of 12 and a root radius of 16, using 16 points to discretise the radius. A mesh is</span>
<span class="sd">    generated with a maximum triangular area of 5.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.CruciformSection(d=250, b=175, t=12, r=16, n_r=16)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0])</span>

<span class="sd">    ..  figure:: ../images/sections/cruciform_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Cruciform section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/cruciform_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the CruciformSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># add first two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the bottom right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the top right radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># construct the top left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add the next two points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span> <span class="o">-</span><span class="n">t</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">])</span>

        <span class="c1"># construct the bottom left radius</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">t</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_radius</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">n_r</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># build the facet list</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">)))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="PolygonSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.PolygonSection">[docs]</a><span class="k">class</span> <span class="nc">PolygonSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a regular hollow polygon section centered at *(0, 0)*, with a pitch circle</span>
<span class="sd">    diameter of bounding polygon *d*, thickness *t*, number of sides *n_sides* and an optional</span>
<span class="sd">    inner radius *r_in*, using *n_r* points to construct the inner and outer radii (if radii is</span>
<span class="sd">    specified).</span>

<span class="sd">    :param float d: Pitch circle diameter of the outer bounding polygon (i.e. diameter of circle</span>
<span class="sd">        that passes through all vertices of the outer polygon)</span>
<span class="sd">    :param float t: Thickness of the polygon section wall</span>
<span class="sd">    :param float r_in: Inner radius of the polygon corners. By default, if not specified, a polygon</span>
<span class="sd">        with no corner radii is generated.</span>
<span class="sd">    :param int n_r: Number of points discretising the inner and outer radii, ignored if no inner</span>
<span class="sd">        radii is specified</span>
<span class="sd">    :param rot: Initial counterclockwise rotation in degrees. By default bottom face is aligned</span>
<span class="sd">        with x axis.</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>
<span class="sd">    :raises Exception: Number of sides in polygon must be greater than or equal to 3</span>

<span class="sd">    The following example creates an Octagonal section (8 sides) with a diameter of 200, a</span>
<span class="sd">    thickness of 6 and an inner radius of 20, using 12 points to discretise the inner and outer</span>
<span class="sd">    radii. A mesh is generated with a maximum triangular area of 5::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.PolygonSection(d=200, t=6, n_sides=8, r_in=20, n_r=12)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5])</span>

<span class="sd">    ..  figure:: ../images/sections/polygon_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Octagonal section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/polygon_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">n_sides</span><span class="p">,</span> <span class="n">r_in</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_r</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the PolygonSection class.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">n_sides</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;n_sides required to be greater than 3 for PolygonSection class&#39;</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># initial rotation</span>
        <span class="n">rot</span> <span class="o">=</span> <span class="n">rot</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>  <span class="c1"># radians</span>

        <span class="c1"># determine triangular segment angle</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">n_sides</span>  <span class="c1"># radians</span>

        <span class="c1"># determine distance from origin to point perpendicular on face of side</span>
        <span class="n">a_out</span> <span class="o">=</span> <span class="n">d</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">a_in</span> <span class="o">=</span> <span class="n">a_out</span> <span class="o">-</span> <span class="n">t</span>

        <span class="c1"># determine side length for outer &amp; inner faces neglecting radii</span>
        <span class="n">side_length_out</span> <span class="o">=</span> <span class="n">d</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">side_length_in</span> <span class="o">=</span> <span class="n">a_in</span> <span class="o">/</span> <span class="n">a_out</span> <span class="o">*</span> <span class="n">side_length_out</span>

        <span class="c1"># check limit on internal radii, if exceeded then radii merge to circle</span>
        <span class="k">if</span> <span class="n">r_in</span> <span class="o">&gt;</span> <span class="n">a_in</span><span class="p">:</span>
            <span class="n">r_in</span> <span class="o">=</span> <span class="n">a_in</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># calculate external radius, if r_in is zero, r_out also is zero</span>
        <span class="k">if</span> <span class="n">r_in</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">r_out</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n_r</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r_out</span> <span class="o">=</span> <span class="n">r_in</span> <span class="o">+</span> <span class="n">t</span>

        <span class="c1"># equivalent side length of half the corner radii triangular segment</span>
        <span class="n">c_out</span> <span class="o">=</span> <span class="n">r_out</span> <span class="o">*</span> <span class="p">(</span><span class="n">side_length_out</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a_out</span>
        <span class="n">c_in</span> <span class="o">=</span> <span class="n">r_in</span> <span class="o">*</span> <span class="p">(</span><span class="n">side_length_in</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">a_in</span>

        <span class="c1"># determine straight side length between corner radii (if present)</span>
        <span class="n">side_length_straight_out</span> <span class="o">=</span> <span class="n">side_length_out</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c_out</span><span class="p">)</span>
        <span class="n">side_length_straight_in</span> <span class="o">=</span> <span class="n">side_length_in</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">c_in</span><span class="p">)</span>

        <span class="c1"># assign control point central on bottom side length &amp; rotate to initial rotation specified</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">a_out</span> <span class="o">+</span> <span class="n">t</span> <span class="o">/</span> <span class="mi">2</span><span class="p">],</span> <span class="n">rot</span><span class="p">)]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># temp list for repeating geometry</span>
        <span class="n">base_points</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># specify a hole in the centre of the Polygon section</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># start at bottom face, constructing one corner radii, then rotate by initial rotation +</span>
        <span class="c1"># alpha and repeat for n_side number of times to form full section perimeter</span>

        <span class="c1"># construct the first radius (bottom right)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_r</span><span class="p">):</span>
            <span class="c1"># determine polar angle</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span>

            <span class="c1"># calculate location of inner and outer points</span>
            <span class="n">x_outer</span> <span class="o">=</span> <span class="n">side_length_straight_out</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_outer</span> <span class="o">=</span> <span class="o">-</span><span class="n">a_out</span> <span class="o">+</span> <span class="n">r_out</span> <span class="o">-</span> <span class="n">r_out</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">x_inner</span> <span class="o">=</span> <span class="n">side_length_straight_in</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">y_inner</span> <span class="o">=</span> <span class="o">-</span><span class="n">a_in</span> <span class="o">+</span> <span class="n">r_in</span> <span class="o">-</span> <span class="n">r_in</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

            <span class="c1"># append the current temporary points to the temporary points list</span>
            <span class="n">base_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_outer</span><span class="p">,</span> <span class="n">y_outer</span><span class="p">])</span>
            <span class="n">base_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_inner</span><span class="p">,</span> <span class="n">y_inner</span><span class="p">])</span>

        <span class="c1"># if radii merged to circle with an outer diameter of a_out then skip last point as causes</span>
        <span class="c1"># overlapping end points which causes meshing issues if geometry is not cleaned by user</span>
        <span class="k">if</span> <span class="n">circle</span><span class="p">:</span>
            <span class="n">base_points</span> <span class="o">=</span> <span class="n">base_points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

        <span class="c1"># iterate and add subsequent corner radii one point at a time for each side</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_sides</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">base_points</span><span class="p">:</span>
                <span class="n">point_new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">alpha</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="n">rot</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_new</span><span class="p">)</span>

        <span class="c1"># build the facet list</span>
        <span class="n">num_points</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_points</span><span class="p">):</span>
            <span class="c1"># if we are not at the last point</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">num_points</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">3</span><span class="p">])</span>
            <span class="c1"># if we are at the last point, complete the loop</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">,</span> <span class="n">angle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotate a point counterclockwise by a given angle around origin [0, 0]</span>

<span class="sd">        :param list point: Point coordinates to be rotated</span>
<span class="sd">        :param float angle: Angle to rotate point coordinates</span>
<span class="sd">        :return: Coordinates of rotated point</span>
<span class="sd">        :rtype: list[float, float]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pt_x</span><span class="p">,</span> <span class="n">pt_y</span> <span class="o">=</span> <span class="n">point</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

        <span class="n">new_x</span> <span class="o">=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">pt_x</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">pt_y</span>
        <span class="n">new_y</span> <span class="o">=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">pt_x</span> <span class="o">+</span> <span class="n">c</span> <span class="o">*</span> <span class="n">pt_y</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">new_x</span><span class="p">,</span> <span class="n">new_y</span><span class="p">]</span></div>


<div class="viewcode-block" id="BoxGirderSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.BoxGirderSection">[docs]</a><span class="k">class</span> <span class="nc">BoxGirderSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Constructs a Box Girder section centered at at *(max(b_t, b_b)/2, d/2)*, with depth *d*, top</span>
<span class="sd">    width *b_t*, bottom width *b_b*, top flange thickness *t_ft*, bottom flange thickness *t_fb*</span>
<span class="sd">    and web thickness *t_w*.</span>

<span class="sd">    :param float d: Depth of the Box Girder section</span>
<span class="sd">    :param float b_t: Top width of the Box Girder section</span>
<span class="sd">    :param float b_b: Bottom width of the Box Girder section</span>
<span class="sd">    :param float t_ft: Top lange thickness of the Box Girder section</span>
<span class="sd">    :param float t_fb: Bottom flange thickness of the Box Girder section</span>
<span class="sd">    :param float t_w: Web thickness of the Box Girder section</span>
<span class="sd">    :param shift: Vector that shifts the cross-section by *(x, y)*</span>
<span class="sd">    :type shift: list[float, float]</span>

<span class="sd">    The following example creates a Box Gider section with a depth of 1200, a top width of 1200, a</span>
<span class="sd">    bottom width of 400, a top flange thickness of 16, a bottom flange thickness of 12 and a web</span>
<span class="sd">    thickness of 8. A mesh is generated with a maximum triangular area of 5.0::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        geometry = sections.BoxGirderSection(d=1200, b_t=1200, b_b=400, t_ft=100, t_fb=80, t_w=50)</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[200.0])</span>

<span class="sd">    ..  figure:: ../images/sections/box_girder_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Box Girder geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/box_girder_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Mesh generated from the above geometry.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">,</span> <span class="n">t_ft</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">,</span> <span class="n">t_w</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot;Inits the BoxGirderSection class.&quot;&quot;&quot;</span>

        <span class="c1"># assign control point</span>
        <span class="n">control_points</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">max</span><span class="p">(</span><span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t_fb</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">control_points</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span>

        <span class="c1"># calculate central axis</span>
        <span class="n">x_c</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">b_t</span><span class="p">,</span> <span class="n">b_b</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>

        <span class="c1"># specify a hole in the centre of the Box Girder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">holes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x_c</span><span class="p">,</span> <span class="n">d</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">]]</span>

        <span class="c1"># determine side wall angle</span>
        <span class="k">if</span> <span class="n">b_t</span> <span class="o">&lt;</span> <span class="n">b_b</span><span class="p">:</span>
            <span class="n">phi_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_b</span> <span class="o">-</span> <span class="n">b_t</span><span class="p">))</span>
            <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phi_b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">phi_t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">b_t</span> <span class="o">-</span> <span class="n">b_b</span><span class="p">))</span>
            <span class="n">phi_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phi_t</span>

        <span class="c1"># determine inner wall x-offsets</span>
        <span class="n">x_bot</span> <span class="o">=</span> <span class="n">t_fb</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phi_b</span><span class="p">)</span>
        <span class="n">x_top</span> <span class="o">=</span> <span class="n">t_ft</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phi_t</span><span class="p">)</span>
        <span class="n">web_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t_w</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">-</span> <span class="n">phi_b</span><span class="p">))</span>

        <span class="c1"># add outer points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_b</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_t</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_t</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>

        <span class="c1"># add inner points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_b</span> <span class="o">-</span> <span class="n">x_bot</span> <span class="o">+</span> <span class="n">web_x</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_b</span> <span class="o">+</span> <span class="n">x_bot</span> <span class="o">-</span> <span class="n">web_x</span><span class="p">,</span> <span class="n">t_fb</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_t</span> <span class="o">+</span> <span class="n">x_top</span> <span class="o">-</span> <span class="n">web_x</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x_c</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">b_t</span> <span class="o">-</span> <span class="n">x_top</span> <span class="o">+</span> <span class="n">web_x</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="n">t_ft</span><span class="p">])</span>

        <span class="c1"># build facet list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">facets</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shift_section</span><span class="p">()</span></div>


<div class="viewcode-block" id="MergedSection"><a class="viewcode-back" href="../../../rst/geom_mesh.html#sectionproperties.pre.sections.MergedSection">[docs]</a><span class="k">class</span> <span class="nc">MergedSection</span><span class="p">(</span><span class="n">Geometry</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Merges a number of section geometries into one geometry. Note that for the meshing algorithm</span>
<span class="sd">    to work, there needs to be connectivity between all regions of the provided geometries.</span>
<span class="sd">    Overlapping of geometries is permitted.</span>

<span class="sd">    :param sections: A list of geometry objects to merge into one</span>
<span class="sd">        :class:`~sectionproperties.pre.sections.Geometry` object</span>
<span class="sd">    :type sections: list[:class:`~sectionproperties.pre.sections.Geometry`]</span>

<span class="sd">    The following example creates a combined cross-section with a 150x100x6 RHS placed on its side</span>
<span class="sd">    on top of a 200UB25.4. A mesh is generated with a maximum triangle size of 5.0 for the</span>
<span class="sd">    I-section and 2.5 for the RHS::</span>

<span class="sd">        import sectionproperties.pre.sections as sections</span>

<span class="sd">        isection = sections.ISection(d=203, b=133, t_f=7.8, t_w=5.8, r=8.9, n_r=8)</span>
<span class="sd">        box = sections.Rhs(d=100, b=150, t=6, r_out=15, n_r=8, shift=[-8.5, 203])</span>

<span class="sd">        geometry = sections.MergedSection([isection, box])</span>
<span class="sd">        geometry.clean_geometry()</span>
<span class="sd">        mesh = geometry.create_mesh(mesh_sizes=[5.0, 2.5])</span>

<span class="sd">    ..  figure:: ../images/sections/merged_geometry.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>

<span class="sd">        Merged section geometry.</span>

<span class="sd">    ..  figure:: ../images/sections/merged_mesh.png</span>
<span class="sd">        :align: center</span>
<span class="sd">        :scale: 75 %</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inits the MergedSection class.&quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">point_count</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># loop through all sections</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="c1"># add facets</span>
            <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">facets</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">facets</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">facet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_count</span><span class="p">,</span> <span class="n">facet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">point_count</span><span class="p">])</span>

            <span class="c1"># add points and count points</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">point_count</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># add holes</span>
            <span class="k">for</span> <span class="n">hole</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">holes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">holes</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">hole</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">hole</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># add control points</span>
            <span class="k">for</span> <span class="n">control_point</span> <span class="ow">in</span> <span class="n">section</span><span class="o">.</span><span class="n">control_points</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">control_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">control_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">control_point</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Robbie van Leeuwen

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>